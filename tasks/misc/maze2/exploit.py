import json
from os import system
from time import time, sleep
from termcolor import colored

from websocket import create_connection
from pyfiglet import Figlet

font = Figlet(font="slant")

#url = "ws://0.0.0.0:8080/ws"
url = "wss://maze2.web1.nto.sprush.rocks/ws"
ws = create_connection(url)

ret = {"left": "right", "right": "left", "up": "down", "down": "up", "": ""}

#step by step maze
a = 200 * 2 + 2
b = 200 * 2 + 2
m = [["." for i in range(a)] for j in range(b)]
c = []

moves_map = {"left": -1, "right": 1, "up": -1, "down": 1}


def print_maze(m, pos, scale=25):
    system("clear")
    y, x = pos
    #beg, end1 = 0, b
    beg = max(y - scale, 0)
    if beg + scale > b:
        beg = b - 2 * scale
        end1 = b
    else:
        end1 = beg + scale
    print(beg, end1)
    for i in range(beg, end1):
        r = m[i]
        print("".join(r))

    print(font.renderText(f"Cur: {pos}"))
    print(font.renderText(f"End: {end}"))


def update_maze(m, pos, flag, col="red"):
    x, y = pos
    if flag:
        m[x][y] = colored("#", col)
        return
    m[x][y] = "#"


def init_maze():
    m = [["." for i in range(a)] for j in range(b)]
    c = [["" for i in range(a)] for j in range(b)]
    return m, c


def solve_maze_req(ws, last_move="", last_pos=[], maze=m):
    recv = ws.recv()
    recv = json.loads(recv)
    pos, end, possible_moves, status = (
        recv["position"],
        recv["end"],
        recv["possible_moves"],
        recv["status"],
    )
    update_maze(m, pos, True)
    print_maze(m, pos)

    for i in possible_moves:
        if i == last_move:
            continue

        ws.send(i)

        if i in ["left", "right"]:
            new_pos = [pos[0], pos[1] + moves_map[i]]
        else:
            new_pos = [pos[0] + moves_map[i], pos[1]]

        if new_pos == end:
            y = time()
            print(y - x)
            return recv

        ans = solve_maze_req(ws, ret[i], possible_moves, m)

        if ans:
            return ans

    ws.send(last_move)
    ws.recv()
    # update_maze(m, pos, False)
    return False


def solve_maze_iter(ws, been=c, maze=m):
    data = []
    previous_move = ""

    start = time()
    moves = 0

    while True:
        recv = ws.recv()
        recv = json.loads(recv)
        pos, end, possible_moves, status = (
            recv["position"],
            recv["end"],
            recv["possible_moves"],
            recv["status"],
        )

        x, y = pos
        if m[x][y] == ".":
            update_maze(m, pos, True)
            print_maze(m, pos)
            if previous_move != "":

                ind = possible_moves.index(ret[previous_move])
                r = possible_moves.pop(ind)
                possible_moves.append(r)

                been[x][y] = possible_moves[-1]

            data = possible_moves + data

        elif data[0] == been[x][y]:
            update_maze(m, pos, False)
        else:
            update_maze(m, pos, True)

        if len(possible_moves) == 1:
            update_maze(m, pos, False)

        i = data.pop(0)
        ws.send(i)
        moves += 1
        previous_move = i

        if i in ["left", "right"]:
            new_pos = [pos[0], pos[1] + moves_map[i]]
        else:
            new_pos = [pos[0] + moves_map[i], pos[1]]

        if new_pos == end:
            end = time()
            return end - start, moves
        
        if moves % 1000 == 0:
            print(moves, time() - start)


counter = 0
t = 0
while True:
    #    system("clear")
    print(font.renderText(f"ROUND {counter}"))
    recv = ws.recv()
    recv = json.loads(recv)
    pos, end, possible_moves, status = (
        recv["position"],
        recv["end"],
        recv["possible_moves"],
        recv["status"],
    )
    if "NTO" in status:
        print(status)
        break

    ws.send(possible_moves[0])
    beg = pos
    m, c = init_maze()
    update_maze(m, beg, True, "green")
    update_maze(m, end, True, "green")
    print_maze(m, beg)

    t, moves = solve_maze_iter(ws, maze=m, been=c)
    print(f"time elapsed: {t}. Moves: {moves}")

    counter += 1
